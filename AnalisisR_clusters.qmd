---
title: "Tarea_C9_final"
format: html
editor: visual
---

## **Caracterización de vinos blancos y tintos a partir de variables fisicoquímicas**

**Clustering**

**\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_**

-   librerías

```{r}
library(factoextra)
library(readxl)
library(tibble)
library(faraway)
library(visdat) 
library(arsenal)
library(ggplot2)
library(GGally)
library(ggeffects)
library(rgl)
library(pROC)
library(car)
library(sjPlot) 
library(performance) 
library(dplyr)
library(cluster)
library(pheatmap)
library(fmsb) 
```

**Pasos**

1.      descriptiva uni y bivariada de las variables físico-químicas.

```{r}
# UNIVARIADA

# analítica
summary(bd)
vis_miss(bd)

# gráfica
# histogramas
hist(bd$acidez_fija)
hist(bd$acidez_volatil)
hist(bd$acido_citrico)
hist(bd$azucares_residuales)
hist(bd$cloruros)
hist(bd$dioxido_azufre_libre)
hist(bd$dioxido_azufre_total)
hist(bd$densidad)
hist(bd$pH)
hist(bd$sulfatos)
hist(bd$alcohol)
hist(bd$calidad)

# boxplot
boxplot(bd$acidez_fija)
boxplot(bd$acidez_volatil)
boxplot(bd$acido_citrico)
boxplot(bd$azucares_residuales)
boxplot(bd$cloruros)
boxplot(bd$dioxido_azufre_libre)
boxplot(bd$dioxido_azufre_total)
boxplot(bd$densidad)
boxplot(bd$pH)
boxplot(bd$sulfatos)
boxplot(bd$alcohol)
boxplot(bd$calidad)

tabla <- tableby(~ ., data=bd) 
summary(tabla, text = TRUE)

# bivariada
ggpairs(bd)

# heatmap 
ggcorr(bd, label = TRUE, label_size = 3, label_round = 2)

```

2.     Detección de outliers multivariados.

```{r}

#distancia de Mahalanobis para identificar multivariadas
s<-cov(bd)  #matriz de covarianzas

centroide<-colMeans(bd)
m_dist <-mahalanobis(bd,centroide,s)

# valor crítico chi-cuadrado 
p <- ncol(bd)
cutoff <- qchisq(0.95, df = p)

# identificar outliers (147)
which(m_dist > cutoff)

hist(m_dist)

# elección de nuevo cutoff para que haya menos outliers.
which(m_dist > 70)

# nueva bd sin esos 19 outliers
bd2 <- bd[-c(82,87,92,93,107,152,259,481,653,724,1080,1082,1236,1245,1435,1436,1475,1477,1575),]
```

outliers finales:

```         
 [1]   82   87   92   93  107  152  259  481  653  724 1080 1082 1236 1245 1435 1436 1475 1477 1575
```

3.      Estandarización de los datos y análisis de cluster jerárquico utilizando distancia euclídea.  

```{r}
#Matriz de distancias estandarizadas
#estandarizacion con bd sin outliers
z<-scale(bd2)

#calculamos dist
dz<-dist(z, method = "euclidean") # matriz distancias 

#Otra opcion (no es necesario convertir a matriz ni estandarizar previamente):
dist <- get_dist(bd2, stand = TRUE, method = "euclidean")

#visualizamos distancias
fviz_dist(dist,
          gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
```

a.     ligamiento simple  

```{r}
c1<-hclust(dz, method = "single", members = NULL)
plot(c1)
d1<-cophenetic(c1)
cor(d1,dz)
```

b.      ligamiento completo

```{r}
c2<-hclust(dz, method = "complete", members = NULL)
plot(c2)
d2<-cophenetic(c2)
cor(d2,dz)
```

c.      ligamiento centroide

```{r}
c3<-hclust(dz, method = "centroid", members = NULL)
plot(c3)
d3<-cophenetic(c3)
cor(d3,dz)
```

d.     ligamiento Ward

```{r}

c4<-hclust(dz, method = "ward.D", members = NULL)
plot(c4)
d4<-cophenetic(c4)
cor(d4,dz)
```

4.      Determinar el número óptimo de clusters.

```{r}
#1. metodo Elbow
fviz_nbclust(z, FUN = hcut, method = "wss") +
  labs(subtitle = "Método Elbow")

#generamos 3 grupos
fviz_nbclust(z,FUN = hcut, method = "wss") +
  geom_vline(xintercept = 3, linetype = 2)

#2. metodo silhouette
fviz_nbclust(z, FUN = hcut, method = "silhouette")+
  labs(subtitle = "Método silhouette")
```

5 Determinar mejor método de alineamiento

```{r}
# simple
View(bd2)
hc.cut <- hcut(bd2, k = 2, hc_method = "single", hc_metric = "euclidean", stand = TRUE)
fviz_silhouette(hc.cut, label=TRUE)

# centroide
hc.cut <- hcut(bd2, k = 2, hc_method = "centroid", hc_metric = "euclidean", stand = TRUE)
fviz_silhouette(hc.cut, label=TRUE)

# completo
hc.cut <- hcut(bd2, k = 2, hc_method = "complete", hc_metric = "euclidean", stand = TRUE)
fviz_silhouette(hc.cut, label=TRUE)

# ward
hc.cut <- hcut(bd2, k = 2, hc_method = "ward.D", hc_metric = "euclidean", stand = TRUE)
fviz_silhouette(hc.cut, label=TRUE)

#Le asignamos a cada objeto el cluster de pertenencia
bd2$grupo <-cutree(hc.cut, k=2)
View(bd2)

# dendrograma con dos clusters, método ward.
fviz_dend(c4, cex = 0.5, k = 2)

#descriptiva por cluster
tab1 <- tableby(grupo ~ ., data=bd2) 
summary(tab1, text=T)
```

6.      Heatmap de vinos  por variables físico-químicas.

```{r}
num_vars <- sapply(bd2, is.numeric) 

mat <- scale(bd2[, num_vars]) 

pheatmap(mat, clustering_distance_rows = "euclidean", clustering_distance_cols = "euclidean", clustering_method = "ward.D2", # podés probar otros 
         color = colorRampPalette(c("navy", "white", "firebrick3"))(50), main = "Heatmap de vinos por variables físico-químicas") 
```

7.      Comparación de los grupos en relación a las variables físico-químicas y a la calidad.

```{r}

grafico <- fviz_cluster(hc.cut, data = bd2, 
             geom = "point", 
             ellipse.type = "convex", 
             palette = "jco", 
             ggtheme = theme_minimal())
grafico

#medias por grupo 
media_grupo <- bd2 %>% group_by(grupo) %>% summarise(across(acidez_fija:calidad, mean, na.rm = TRUE)) 
media_grupo

#rescalar(0-1) para que todas las variables estén en misma escala 
media_norm <- as.data.frame(scale(media_grupo)) 
rownames(media_norm) <- paste("Grupo", media_grupo$grupo) 
media_norm

#preparar para radarchart 
df_radar <- rbind(apply(media_norm, 2, max), apply(media_norm, 2, min), media_norm) 
radarchart(df_radar, axistype = 1, pcol = 1:4, plwd = 2, plty = 1, title = "Perfiles promedio de cada grupo") 
legend("topright", legend = rownames(media_norm), col = 1:4, lty = 1, lwd = 2, bty = "n") 

# pheatmap
cluster = bd2$grupo 
medias <- aggregate(bd2[,1:12], by=list(cluster=cluster), mean) 
row.names(medias) <- paste("Cluster", medias$cluster) 
pheatmap(as.matrix(medias[,-1]), scale="column")
 
```

8.      Agrupamiento de k-means en 6 grupso. Comparación con los grupos creados inicialmente.

```{r}
c5<-kmeans(z, centers=6,iter.max = 100)

# tabla, fijarse p valor menor a 0.05
tab1 <- tableby(grupo ~ ., data=bd2)
summary(tab1, text=T)

# generar columna con los grupos según k mean
bd2$grupo2 <- c5$cluster
tab1 <- tableby(grupo2 ~ ., data=bd2)
summary(tab1, text=T)
# comparar ambos métodos y ver en cuales coinciden bastantes casos.
# generar un método de agrupamiento con 6 casos antes.
table(bd2$grupo, bd2$grupo2)

```
